The General Schema Language
***************************

Author:
  iMatix Corporation <tools@imatix.com>
Revised:
  1999/07/20

Introduction
************

What is GSLgen?

- GSLgen is a general-purpose file generator.
- Its purpose is to generate code, data or other files from an
  XML file and a schema file.  The XML file defines
  a particular set of data.  The schema file (henceforth referred to
  as simply the schema) tells GSLgen what to do with that data.
- GSLgen allows an orthogonal separation between an 
  application and its implementation.
- You should be comfortable with the basic concepts of the Extensible
  Markup Language (XML).

What are the alternatives?

- A lot of work by hand.

Copyright and Distribution
==========================

GSLgen is copyright (c) 1996-99 iMatix Corporation, and is distributed
under an Open Source license as described in the file license.txt that is
supplied with GSLgen.  This license basically grants you the right to use
GSLgen for any purpose, and to distribute modified copies of GSLgen without
restriction.  To conform with the license agreement you should acknowledge
the use of GSLgen in your commercial products.


Installing GSLgen
*****************

GSLgen is provided as a ready-to-run executable for Windows (95/98 and NT),
OS/2 (requires EMX), and Linux.  For other platforms you can rebuild GSLgen
from the provided sources very easily.  Install and build the SFL library
from imatix.com, then build GSLgen using the 'build' script provided in the
src subdirectory.  You do need to copy libsfl and sfl.h from the SFL
directory into the src subdirectory.

Using GSLgen 
************

Description
===========

GSLgen is a general-purpose file generator. Its purpose is to generate code,
data or other files from an XML file and a schema.

Command-line Syntax
-------------------

To run GSLgen, use the following syntax
    gslgen -<option> ... -<attr>[:<value>] ... filename ...

Where filename is assumed to have an extension '.xml'
if necessary.

Options currently recognised by GSLgen are:

q, quiet:
    Suppresses copyright and other messages from GSLgen.

Attributes may have any legal XML name and value.  GSLgen copies
these attributes to the top-level item in the XML file(s) before code
generation begins.  The schema may access the value of these attributes
in the same way as any attribute defined in the XML file.

Getting Started
---------------

How do I use GSLgen?

- If you have an XML file entitled test.xml, the simplest way to
invoke GSLgen is

    gslgen test.xml

- In this case the schema must be defined as an attribute of the top-level
  item defined in test.xml.  If this is not the case, or if you wish to
  use a different schema, use the form

    gslgen -schema:xxxxxxx.sch test.xml

- See GSLgen reference for a complete description of the command-line
syntax.

A Hello World Example
---------------------

Try a 'hello world' test:

hello.xml:

    <HWML>
    <WORLD NAME="World">
        <HELLO NAME="Hello" />
    </WORLD>
    </HWML>

hello.sch (dot starts in first column):

    .for world
    .  for hello
    .    echo "$(name) $(world.name)"
    .  endfor
    .endfor

Then, run GSLgen:

    gslgen -schema:hello.sch hello.xml

A More Complex Example
----------------------

This is a schema which generates a simple DOS batch file to install programs
by copying them into various directories.  It's something you might want to
generate for specific projects:

    .- 
    .- install.sch   Generates install script from install.xml
    .-
    .output "install.bat"
    @echo off
    rem generated by gslgen from install.xml, $(schema)
    .for file
    .  if     type = "binary"
    echo $(name) -- \\usr\\bin
    copy $(name) \\usr\\bin >nul
    .  elsif type = "schema"
    echo $(name) -- \\usr\\lib
    copy $(name) \\usr\\lib >nul
    .  elsif type = "doc"
    echo $(name) -- \\usr\\doc
    copy $(name) \\usr\\doc >nul
    .  endif
    copy $(name) install >nul
    .endfor

The input is an XML file like this:

    <INSTALL SCHEMA="install.sch">
    <FILE name="gslgen.exe"  type="binary" />
    <FILE name="gslgen.htm"  type="doc"    />
    <FILE name="install.sch" type="schema" />
    <FILE name="hello.sch"   type="schema" />
    </INSTALL>

We run GSLgen to process the XML file:

    gslgen install.xml

This is the result:

    @echo off
    rem generated by gslgen from install.xml, install.sch
    echo gslgen.exe -- \usr\bin
    copy gslgen.exe \usr\bin >nul
    copy gslgen.exe install >nul
    echo gslgen.htm -- \usr\doc
    copy gslgen.htm \usr\doc >nul
    copy gslgen.htm install >nul
    echo install.sch -- \usr\lib
    copy install.sch \usr\lib >nul
    copy install.sch install >nul
    echo hello.sch -- \usr\lib
    copy hello.sch \usr\lib >nul
    copy hello.sch install >nul

Another Complex Example
-----------------------

Try this command:

    gslgen -schema:xmlfile.sch spfper.dbm

This generates a C function, spfper.c, which handles a data table (in this
case a list of persons) as an XML file, with functions to read, save, and
update data in this table.  This is a good example of a complex GSL schema,
and one that is used in real life to handle data objects in iMatix Studio.

The General Schema Language (GSL) 
*********************************

Description
===========

GSL is a schema language developed by iMatix Corporation. Its purpose is to
provide a simple yet powerful means of building files which contain a
mixture of fixed and variable data extracted from separate source files. The
variable data is read from an XML file. The schema contains both the fixed
data and controls to insert the variable data as necessary.

GSL is actually closely related to a reporting language such as is used to
generate reports from a relational database. It differs mainly in that it is
designed to generate many different reports into as many output files as
required.

Many GSL concepts are borrowed directly from database terminology, to which
it is closely related.

Scopes
======

A scope is a level of data definition.  Each scope has a name, a value and
a series of attributes, each of which has a name and value.  Most scopes
are associated with XML items; they usually have the same name, value and
attribute names and values.  See the description of the .for, .new and
.invoke commands.

At the start of processing of a schema, one scope is implicitly defined
by GSLgen.  It corresponds to the top-level item of the XML file.  We refer
to this scope as the root scope.

The .for, .new and .invoke constructs create new scopes.  A new scope
is considered to lie within the scopes that were open before it.  The
new scope can be considered to inherit attributes from the scopes
which are already open.   Scopes can be visualised as a series of
hierarchically nested data structures.

Data Types
==========

GSLgen supports two data types: numeric and string.
However it makes no formal distinction between them; if a value looks
numeric then it is treated as such, otherwise it is treated as a string.

Constants
=========

A string constant is specified with either single- or double-quotes as
delimiters, for example: "ABC".  A numeric constant may be  specified
in the same way or as a simple signed number, for example 123.  String
constants may continue over several source lines.  The line break is
considered part of the string constant, unless the last character in
the line is a single backslash ('\') in which case neither the
backslash nor the line break is part of the string.

Identifiers
===========

Identifiers in GSL refer to XML attribute values or item values.
There are six different forms of identifier specification:

<scope>. <attr>:
    A full attribute specification.  Eg.  PAGE.LENGTH
<attr>:
    An attribute specification with no scope specified.  In this case GSL
    will search for an attribute with the given name in all the open scopes,
    starting with the innermost.  Eg.  DATE
<scope>.:
    An item value specification.  This refers to the value of
    the scope object itself.  Eg.  PAGE.
.:
    An item value specification with no scope specified.  This refers 
    to the value of the innermost scope.
<scope>-> <item>:
    An item value specification, where <item> is the name of a child of the
    XML item corresponding to the scope.  If more than one child exists with
    the given name, only the first is used; if no such child exists, the
    result is undefined.
-> <item>:
    As above, using the innermost scope block.

Expressions
===========

GSL expressions are much the same as expressions in other high-level
programming languages.  They include the following operators:

Multiplicative:
    *, /
Additive:
    +, -
Comparative:
    =, <>, >, >=, <, <=
Safe comparative:
    ?=, ?<>, ?>, ?>=, ?<, ?<=
Logical:
    |, &, !

Operator precedence is standard (multiplicative, additive, comparative,
logical) and brackets are treated as you would expect.

Logical operators treat zero as FALSE and non-zero as TRUE.

GSLgen optimises expression evaluation to the extent that the second
operand of a binary logical operator ('|', '&') is not evaluated if
the result of the expression is determined by the first operand.  This
allows you to use expressions such as

    defined (X) & X

since the second operator is not evaluated when X is undefined.

The safe comparative operators return the same result as their equivalent
comparative operators when both operands are defined.  If one or both 
operator is undefined, the safe operators return FALSE while the normal
operators produce an error.

An operand is treated as numeric or string depending on its value.
Generally, additive, multiplicative and logical operators only apply to
numeric operands.  There are two cases where an arithmetic operator can
apply to string values:

+:
    "ABC" + "DEF" results in "ABCDEF"
*:
    "AB" * 3 results in "ABABAB"  Note that "9" * 3 results in 27, since
    GSLgen makes no distinction between "9" and 9.

Built-In Functions
==================

count  ([<scope> '.'] <child>, <expression>):
    counts the number of children of the supplied or innermost scope
    of the given name.  If an expression is specified, it is treated as
    a condition to determine which children are counted.  In this case,
    a new scope 'COUNT' is implicitly defined while the condition is
    evaluated.  For example: count (ITEM, COUNT.NAME = "ABC")
    returns the number of children of the innermost scope whose attribute
    NAME has the value "ABC".
index  ([<scope>]):
    returns the index of the item associated with the supplied or innermost
    scope.  See the description of the .for command.
name ([<scope>]):
    returns the item name associated with the supplied or innermost
    scope.  See the description of the .for command.
exists (<FileName>):
    returns a logical value (1 or 0) depending on whether a file of the given
    name exists of not.
timestamp (<FileName>):
    returns the modification time of the file as a sixteen-character string
    CCYYMMDDHHMMSS00; undefined if the file does not exist.
logical value (1 or 0) depending on whether a file of the given
    name exists of not.
defined ([Ident '.'] Ident):
    returns a logical value (1 or 0) depending on whether the specified
    identifier is defined or not.
env (var):
    returns the value of an environment variable.
length (string):
    returns the length of a string (or number considered as a string).
substr (string, start, end, length):
    returns a substring of the given string.  This may be used in a number of
    ways:

    substr (string, start, end, )    - specify start and end offsets
    substr (string, start, , length) - specify start offset and length
    substr (string, , end, length)   - specify end offset and length
    substr (string, start, , )       - end of string from start offset
    substr (string, , end, )         - same as substr (0, end, )
    substr (string, , , length)      - end of string of given length
trim (string):
    trims a string by removing leading and trailing white space.

Output lines
============

The simplest GSL line is just a line of text, which is copied verbatim
to the current output file.  If no output file has been opened, or if the
last output file has been closed, the output is copied to the standard
output.

If the output line contains a backslash ('\') in any position except
for the last character then the backslash is removed at evaluation
time.  This allows characters which would normally be interpreted as
schema commands to be output literally.  To output a backslash, you
must use a double-backslash ('\\').

If the last character of an output line is a backslash ('\') then the line
is output with no line terminator; otherwise a line terminator follows the
output line.

Schema Commands
===============

Besides output lines, schemas also contain schema command lines.  These
are introduced by a period ('.') as the first non-space character in the line.
The schema commands are described below.

A backslash within a schema command line is ignored, just as with
output lines.  Use it to include character sequences which would otherwise be
interpreted as a GSL construct.

If a schema command line ends with a backslash ('\') then the following 
schema line is treated as a continuation of the current line.

Substituting Symbols and Expressions
====================================

At just about any point within an output or schema command line, a
substitute construct may be used instead of literal text.  The
format for expression subsitution is:

    $( <Expression> [? default] [% format] [: pretty-print] )

The order of the default, format and pretty-print modifiers is not
important.

GSLgen attempts to evaluate the expression by resolving identifiers into
their value, performing the arithmetic and evaluating any functions.

The default value is used if the expression value is undefined.
If no default is specified then the value of the substitute construct is
undefined.

If a format string is provided, it is used to format the result before
continuing.  It is a normal C format string; the value is always a string
so the appropriate conversion specifier is %s.

Normally a format
string contains a '%' to introduce the conversion specifier; if this is the
first character of the format string then it may be omitted and the '%'
introducing the format string is implicitly included.  Otherwise the '%' in the
format string must be preceded by a backslash ('\') so that GSLgen does not
interpret it as a second (illegal) format string.
Thus $("XXX"%5s) is equivalent to $("XXX"%\%5s).

The pretty-print modifier specifies how case modification and replacement
of certain characters takes place.  The valid pretty-print modifiers (not
case-sensitive) are:

UPPER:
    UPPER CASE
lower:
    lower case
Neat:
    Neat Case Modification
c:
    substitute_non_alpha_to_make_c_identifier
cobol:
    SUBSTITUTE-NON-ALPHA-TO-MAKE-COBOL-IDENTIFIER

More than one pretty-print modifier may be specified; they should be
separated by commas.

In the specific case where the expression consists of a single identifier
and no case-modifier is specified (c or cobol may still be specified), the
case in which the identifier name is specified is used as an example to
determine whether the case of the result should be modified to UPPER, lower or
Neat.  A final exception is that if an empty pretty-print string is provided,
no case modification is performed.

Some examples:  Assume the identifier IDENT has the value "IDENT value" 
and identifer XXX is undefined.

$(XXX):
    produces a run-time GSLgen error: Undefined expression.
$(XXX?Undefined):
    "Undefined"
$(IDENT%12s):
    " IDENT VALUE"
$(ident:upper):
    "IDENT VALUE"
$(Ident):
    "Ident Value"
$(ident:c):
    "ident_value"
$(IDENT:):
    "IDENT value"

Shuffle
=======

GSLgen can help to keep code neat by enlarging or shrinking white space
so that column numbers match as far as possible between the schema and
the output file.  For instance, in the value of the identifier X is
ABCDEF then:

    $(X)   .

evaluates to

    ABCDEF .

but

    $(X?Undefined) .

evaluates to

    ABCDEF .

The shuffle algorithm uses a parameter 'shuffle' (actually an
attribute of the root item) whose numeric value influences the
operation.  It expands a block of white space longer than 'shuffle' as
much as necessary so that the text following the white space is output
in the same column.  It also shrinks white space down to a minimum of
'shuffle' to make space for text preceeding the white space.  If
'shuffle' is zero, then shuffle is disabled.  The default value of
'shuffle' is 1; this is the value which produces the results shown
above.

If the current output ends with a backslash, then the shuffle continues on
the following line.  Thus

    $(X?Undefined)\\
             .

evaluates to

    ABCDEF   .

Shuffle can cause problems in some cases, for example when outputting
literal text where the size of white space is important.  In this case
shuffle should be disabled with

    .define shuffle = 0

COBOL
=====

GSLgen helps you make neat COBOL code by automatically filling the first
six characters of each line with the four-digit line number followed 
by two zeroes.  To enable this function, define an attribute 'cobol' of the
root item either using

    .define cobol = 1

or

    gslgen -cobol etc.

when you invoke GSLgen, or even (yuk) define an attribute COBOL right in
your XML file.

Predefined Identifiers
======================

There are some identifiers whose value is maintained by GSLgen.  They are
defined as attributes of the root item.

schema:
  The name of schema file currently being processed.
filename:
  The name of the XML file being processed.
outfile:
  The name of the current output file; undefined if there is none.
line:
  The line number of the line currently being output to the output file.
me:
  The name of the current application: gslgen.
version:
  The version of the current application.
date:
  The current date in the format YYYY/MM/DD
time:
  The current time in the format hh:mm:ss


Schema Commands
===============

.output
-------

    .output <filename>

closes the current output file, if one is open, and opens a new one.

Examples
    .output "myfile.c"
    .output FILENAME

where FILENAME is an identifier whose value is the desired file name.

.append
-------

    .append <filename>

closes the current output file, if one is open, and
opens a previously existing one and prepares to extend it.

See the description of the output command for examples.

.close
------

    .close

closes the current output file, if one is open.

.include
--------

    .include <filename>

includes another schema file.

.interpret
----------

    .interpret <expression>

interprets the given expression as GSL,
just as though it were part of the schema.  This is most useful for including
chunks of GSL which themselves come from an XML file.

.echo
-----

    .echo <expression>

outputs the given expression to the standard output.

.abort
------

    .abort <expression>

outputs the given expression to the standard
output and halts GSLgen operation.

.define
-------

    .define [<scope>.] <name> [ <text> | = <expression> ] 

defines or
undefines an XML attribute or item value.  It has several different forms,
described below:

.define <scope>.<name>:
   The identifier's definition is cancelled; it becomes undefined.
.define <scope>.<name> <text>:
   The identifier is given the literal value of <text>.
.define <scope>.<name> = <expression>:
   The identifier is given the result of the evaluation expression.

As during expression evaluation, the scope may be omitted from an
identifier.  In this case, the identifier is defined at the outermost
level.  This effectively makes it a global variable.

If the name is omitted from an identifier, the value of the XML item is 
modified, rather than that of an attribute.

If neither scope nor name is specified, the value of the XML item
associated with the outermost scope is modified.

Notice that there is an ambiguous case of this command

   .define PERSON. ABCDEF

does not assign the string "ABCDEF" to the value of the item PERSON, but
undefines the identifier PERSON.ABCDEF.  To do the former, use

   .define PERSON. = "ABCDEF"

.if
---

    .if <expression>

starts conditional processing of the following block of code if the logical
value of the expression is TRUE.

.elsif
------

    .elsif <expression>

may follow an .if construct.  Any number of .elsif constructs may be used.

.else
-----

    .else

may follow an .if or .elsif construct.  The following block of code is
processed if the logical value of all the expressions is FALSE.

.endif
------

    .endif

terminates a conditional processing construct.

Example

    .if NAME = "JAMES"
    something
    .elsif NAME = "JAIME"
    something else
    .else
    everything else
    .endif

.while
------

    .while <expression>

introduces a loop.  The following block of code is processed repeatedly as long
as the expression evaluates to a logical value of TRUE, that is not equal to
zero.  Expression evaluation takes place before the code is processed, so that
the code will never be processed if the expression evaluates to FALSE the first
time.

.endwhile
---------

    .endwhile

terminates a .while loop.

Example

    .define I = 0
    .while I < 5
    loop iteration number $(I)
    .endwhile

.for
----

    .for [<scope>.] <name> [as <alias>] [where <expression>] [by <expression>]
    .for [<scope>] .       [as <alias>] [where <expression>] [by <expression>]

introduces a loop.  The following block of code is processed once for
each item specified.  If no scope if specified, the innermost scope is
assumed.  The items processed are those children of the XML item
corresponding to the specified scope, or the innermost if none is
specified.  If the first form is used only children with the specified name
are processed; if the second form is used, all children are processed.

The alias allows you to give the new scope a name other than the
specified item name; use this when you nest scopes which would
otherwise have the same name or to supply a scope name when using the
second form.

The where clause allows you to specify a condition which must be
satisfied for the code to be processed; the expression is evaluated
before any processing occurs.

The by clause allows you to sort the
items according to the result of evaluating the expression for each
item.  If no by clause is specified the items are processed from the
oldest to the youngest, the same order in which they are described in
the XML file.

The expressions in the where and by clauses are evaluated within the
scope of the current item; that is a new innermost scope is created
with the name specified by the alias, or name if there is no alias,
having the attributes of the corresponding XML item.  The same scope
exists during the processing of the code block following the .for
statement.

During the evaluation of the for and where expressions, as well as during the
processing of the code, the function index (name) returns the item number of
the item of the current iteration.  Note that the index number of an item
means one more than the number of children of the same parent with the same
name who are older than the current child.  It is not modified by either
the where or by expressions.

.endfor
-------

    .endfor

terminates a .for loop.


Examples

    .for RECORD.FIELD by NAME
    $(FIELD.NAME)
    .endfor

outputs the names of the fields of the current record, sorted in alphabetical
order.

    .for FIELD where index () = 1
    something
    .endfor

processes only the first item named FIELD.

.new
----

    .new [<scope>.] <name> [as <alias>]

creates a new XML item.  This allows you to build new items in the data
tree.  The new item as the specified name and becomes the youngest child of
the XML item
corresponding the the specified scope, or the innermost scope if none is
specified.  The construct creates a new scope with the name specified by
the alias or the item name if there is no alias.  The following block of
code is processed exactly once within this new scope.  It would typically
create some attributes of the new XML item using the .define statement.
These values can then be retrieved during a future iteration of a .for
construct through the new item.

.endnew
-------

    .endnew

terminates a .new construct.

Example

    .new RECORD.FIELD
    .    define FIELD.NAME = "NEW FIELD"
    .endnew

.xml
----

    .xml <filename> [from <scope>]

provides a second way (the first is .new) to build upon the existing data
structure.  The XML file specified by the file name is read and the data tree
is attached to the existing tree at the item corresponding to the specified
scope, or the innermost if none is specified.

.macro
------

    .macro <name> [(<param> [, <param>] ...)]

defines a macro with the specified name.  A macro is used with the .invoke
statement, at which time the code following the .macro statement is
processed.  At this time a new scope is defined with the name of the macro
and having attributes with the names of the parameters in the .macro
construct.  The values of these attributes are specified in the .invoke
statement.

.endmacro
---------

    .endmacro

terminates a .macro construct.

.invoke
-------

    .invoke <name> [([<expression>] [, [<expression>]])] ...)]

causes a previously defined macro to be processed.  An error occurs if the
macro has not been defined.  The number of expressions (or empty expressions)
must match exactly the number of parameters in the macro definition.  An
empty expression or an expression whose value is undefined causes the
corresponding parameter to be undefined during processing of the macro code.

GSLgen Developer's Reference
****************************

GSLgen is provided as an callable function 
This allows you to embed GSLgen's capabilities into your application
program.  Your programming language must be able to link to C subroutines,
since GSLgen is provided as an ANSI C program.  GSLgen uses the iMatix SFL
library, including the sflxml module.

The GSL code generator is accessed through the gg_code() function:

    int gg_code (XML_ITEM *xml_tree);

This is a simple fragment of C code that loads an XML file into memory and
calls the GSL code generator:

    #include "sfl.h"                        /*  Universal include file           */
    #include "ggcode.h"                     /*  GSL header file                  */
    xml_source = xml_load ("PATH", "example.xml");
    ASSERT (xml_source);
    gg_code  (xml_first_child (xml_source));
    xml_free (xml_source);

A fuller example is provided in gslgen.c; this program also parses the
command line, and sets standard values like $(date) and $(time).

