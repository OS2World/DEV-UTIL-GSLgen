.----------------------------------------------------------------------------
.-
.-  Name:       xmlfile.sch
.-  Title:      DBML schema for GSLgen
.-  Written:    1998/08/20    Jonathan Schultz
.-  Revised:    1998/12/31    Jonathan Schultz
.-
.-  Copyright:  Copyright (c) 1996-99 iMatix Corporation
.-
.-  License:    This is Open Source software; you can redistribute it and/or
.-              modify it under the terms of the iMatix Corporation Open
.-              Source License Agreement as provided in the file LICENSE.TXT.
.-              This software is distributed in the hope that it will be
.-              useful, but without any warranty.
.----------------------------------------------------------------------------
.-
.include "predbml.sch"
.-
.macro STRUCT_DECL (NAME, TYPE, SIZE, DECIMAL, MAX)
.    if TYPE = "NUMERIC"
.        if DECIMAL > 0
    double $(name:c);
.        elsif SIZE > 4
    long $(name:c);
.        else
    int  $(name:c);
.        endif
.    elsif TYPE = "DATE" | TYPE = "TIME"
    long $(name:c);
.    elsif TYPE = "BOOLEAN"
    Bool $(name:c);
.    elsif SIZE <= 1
    char $(name:c);
.    else
    char $(name:c%-$(MAX)s) [$(SIZE%4s) + 1];
.    endif
.endmacro
.-
.define TN $(TABLE.NAME:c)
.-
.define SEL_CHAR 40
.output "$(tn).h"
/*---------------------------------------------------------------------------
      FILE :    $(tn).h
      TYPE :    Database IO files for table $(TN:)

      Generated by GSLgen using schema $(schema) at $(date) $(time)
  ---------------------------------------------------------------------------*/
#ifndef _$(TN)_INCLUDED
#define _$(TN)_INCLUDED
#include "dbio.h"

/*- Record structure --------------------------------------------------------*/

typedef struct
{
.for FIELD
.    invoke STRUCT_DECL (NAME, TYPE, SIZE, $(DECIMAL?0), MAXNAMELEN)
.endfor
} $(TN);


.for KEY
typedef struct
{
.    for KEY.FIELD as KEYFIELD
.        invoke STRUCT_DECL (NAME, TYPE, SIZE, $(DECIMAL?0), MAXNAMELEN)
.    endfor
} $(TN)_KEY_$(KEY.CODE);


.endfor
typedef union
{
.for KEY
    $(TN)_KEY_$(KEY.CODE) $(KEY.code);
.endfor
} $(TN)_KEY;


/*- Function declaration ----------------------------------------------------*/

#ifdef __cplusplus
extern "C" {
#endif

int  $(tn)_create           (void);
int  $(tn)_drop             (void);
int  $(tn)_open             (void);
int  $(tn)_get              ($(TN) *record, int pos_mode,
	                     int key, int lock);
int  $(tn)_put              ($(TN) *record);
int  $(tn)_update           ($(TN) *record);
int  $(tn)_delete           ($(TN) *record, int key);
int  $(tn)_commit           (void);
int  $(tn)_close            (void);
void $(tn)_clear            ($(TN) *record);
/* int  $(tn)_rec2key          ($(TN) *record, int key_val, int nb_fields,
                             $(TN)_KEY *key);
int  $(tn)_key2rec          ($(TN) *record, int key_val, int nb_fields,
                             $(TN)_KEY *key); */
#ifdef __cplusplus
}
#endif

#endif
.close
.output "$(tn).c"
/*---------------------------------------------------------------------------
      FILE :    $(tn).c
      TYPE :    Database IO files for table $(TN:)

      Generated by GSLgen using schema $(schema) at $(date) $(time)
  ---------------------------------------------------------------------------*/

#include "sfl.h"                        /*  General definitions              */
#include "dbio.h"
#include "$(name).h"


/*  Type declarations  ------------------------------------------------------*/


typedef struct _RECORD_ITEM        RECORD_ITEM;

struct _RECORD_ITEM {
    TREE
.for KEY
.    if index () < count (TABLE.KEY)
        $(KEY.name)_item,
.    else
        $(KEY.name)_item;
.    endif
.endfor
    $(TN)
        record;
};
 

typedef void *(TREE_FIND) (TREE **root, void *tree, TREE_COMPARE *comp);
typedef void *(TREE_SCAN) (void *tree);


/*  Global variables  -------------------------------------------------------*/

static MEMTRN
    *the_transaction;
static RECORD_ITEM
    *cur_record_item;
static TREE
.for KEY
.     if index () < count (TABLE.KEY)
    *$(KEY.name)_tree = NULL,
.     else
    *$(KEY.name)_tree = NULL;
.     endif
.endfor
static char
    buffer [LINE_MAX + 1];
static XML_ITEM
        *xml_root;


/*  Local function prototypes  ----------------------------------------------*/

static void load_xml_into_record ($(TN) *record,
                                  XML_ITEM *xml_item);
.for KEY
static int  $(KEY.name)_cmp      (void *t1, void *t2);
.endfor
static int read_key_record       ($(TN) *record, 
                                  int key,
                                  TREE_FIND *tree_find);
static int  read_scan_record     ($(TN) *record,
                                  int key,
                                  TREE_SCAN *tree_scan);
static void load_record_into_xml  (void *t);


/*  ---------------------------------------------------------------------[<]-
    Function: $(tn)_create

    Synopsis: Create the table $(TN) and all indexes
    ---------------------------------------------------------------------[>]-*/

int
$(tn)_create (void)
{

.if $(TRACE?0)
    coprintf ("$(tn)_create");

.endif
    xml_root = xml_new (NULL, NULL, NULL);
    xml_save (xml_root, "$(tn).xml");
    xml_free (xml_root);

    return OK;
}


/*  ---------------------------------------------------------------------[<]-
    Function: $(tn)_drop

    Synopsis: Drops the table $(TN)
    ---------------------------------------------------------------------[>]-*/

int
$(tn)_drop (void)
{
.if $(TRACE?0)
    coprintf ("$(tn)_drop");

.endif
    file_delete ("$(tn).xml");

    return OK;
}


/*  ---------------------------------------------------------------------[<]-
    Function: $(tn)_open

    Synopsis: Opens the table $(TN)
    ---------------------------------------------------------------------[>]-*/

int
$(tn)_open (void)
{
    XML_ITEM
        *xml_item;
    $(TN)
        *record;
    int
        feedback = OK;

.if $(TRACE?0)
    coprintf ("$(tn)_open");

.endif

    xml_root = xml_load ("", "$(tn).xml");
    if (!xml_root)
	return HARD_ERROR;

.for KEY
    tree_init (&$(KEY.name)_tree);
.endfor

    the_transaction = mem_new_trans ();
    if (!the_transaction)
	return HARD_ERROR;

    FORCHILDREN (xml_item, xml_root)
      {
	record = memt_alloc (the_transaction, sizeof (*record));
	ASSERT (record);
	load_xml_into_record (record, xml_item);
	feedback = $(tn)_put (record);
        if (feedback)
          {
            mem_free (record);
            break;
          }
      }
    xml_free (xml_root);
    return feedback;
}


void load_xml_into_record ($(TN) *record, XML_ITEM *xml_item)
{
.for FIELD
.    if TYPE = "NUMERIC"
.        if SIZE > 4
        record-> $(name:c) = atol (xml_get_attr (xml_item, "$(name:c)", ""));
.        else
        record-> $(name:c) = atoi (xml_get_attr (xml_item, "$(name:c)", ""));
.        endif
.    elsif TYPE = "DATE" | TYPE = "TIME"
        record-> $(name:c) = atol (xml_get_attr (xml_item, "$(name:c)", ""));
.    elsif TYPE = "BOOLEAN"
        record-> $(name:c) = streq (xml_get_attr (xml_item, "$(name:c)", ""), "TRUE");
.    elsif SIZE <= 1
        record-> $(name:c) = *(xml_get_attr (xml_item, "$(name:c)", ""));
.    else
        strcpy (record-> $(name:c), xml_get_attr (xml_item, "$(name:c)", ""));
.    endif
.endfor
}


/*  ---------------------------------------------------------------------[<]-
    Function: $(tn)_put

    Synopsis: put a record into the table $(TN)
    ---------------------------------------------------------------------[>]-*/
int
$(tn)_put ($(TN) *record)
{
    RECORD_ITEM
        *record_item;
    int
.for KEY
        $(KEY.name)_feedback = DUPLICATE_RECORD,
.endfor
        feedback = OK;

.for KEY where index () = 1
    if ($(KEY.name)_tree == NULL)
        return ILLEGAL_FILE_USAGE;
.endfor

    record_item = memt_alloc (the_transaction, sizeof (RECORD_ITEM));
    ASSERT (record_item);
    memcpy (&record_item-> record, record, sizeof ($(TN)));

.- Go through the keys starting with the unique ones.  ("FALSE" < "TRUE")
.for KEY by DUPLICATES
    if (feedback == OK)
      {
        $(KEY.name)_feedback = tree_insert (&$(KEY.name)_tree,
	                                    &record_item-> $(KEY.name)_item,
			                    $(KEY.name)_cmp,
                                            $(DUPLICATES));
	feedback = $(KEY.name)_feedback;
      }
.endfor

    if (feedback == OK)
        cur_record_item = record_item;
    else
      {
        feedback = DUPLICATE_RECORD;
.for KEY where DUPLICATES = "FALSE"
        if ($(KEY.name)_feedback == OK)
            tree_delete (&$(KEY.name)_tree, &record_item-> $(KEY.name)_item);
.endfor
        mem_free (record_item);
      }

    return feedback;
}


.for KEY
int $(KEY.name)_cmp (void *t1, void *t2)
{
    RECORD_ITEM
        *r1,
        *r2;
    int 
        result;

    r1 = (RECORD_ITEM *) ((char *) t1 - $(index () - 1) * sizeof (TREE));
    r2 = (RECORD_ITEM *) ((char *) t2 - $(index () - 1) * sizeof (TREE));
.    for KEY.FIELD as KEYFIELD
.        if TYPE = "TEXTUAL" & SIZE > 1
    result = strcmp (r1-> record. $(name:c), r2-> record. $(name:c));
    if (result < 0)
	result = -1;
    else
    if (result > 0)
	result = 1;
.        else
    if (r1-> record. $(name:c) > r2-> record. $(name:c))
	result = 1;
    else
    if (r1-> record. $(name:c) < r2-> record. $(name:c))
	result = -1;
    else
        result = 0;

.        endif
.        if index (KEYFIELD) < count (KEY.FIELD)
    if (result != 0)
	return result;

.        else
    return result;
.        endif
.    endfor
}

.endfor
    

/*  ---------------------------------------------------------------------[<]-
    Function: $(tn)_get

    Synopsis: get a record from the table $(TN)
    ---------------------------------------------------------------------[>]-*/

int
$(tn)_get ($(TN) *record, int pos_mode, int key, int lock)
{
    int
        feedback;

.if $(TRACE?0)
    coprintf ("$(tn)_get: pos_mode %d, key %d, lock %d",
              pos_mode, key, lock);

.endif
.for KEY where index () = 1
    if ($(KEY.name)_tree == NULL)
        return ILLEGAL_FILE_USAGE;
.endfor

    switch (pos_mode)
      {
        case THIS_RECORD:
        case EQUAL_TO:           feedback = read_key_record (record,
                                                             key,
                                                             tree_find_eq);
                                 break;
        case GREATER_OR_EQUAL:   feedback = read_key_record (record,
                                                             key,
                                                             tree_find_ge);
                                 break;
        case GREATER_THAN:       feedback = read_key_record (record,
                                                             key,
                                                             tree_find_gt);
                                 break;
        case LESS_THAN:          feedback = read_key_record (record,
                                                             key,
                                                             tree_find_lt);
                                 break;
        case LESS_THAN_OR_EQUAL: feedback = read_key_record (record,
                                                             key,
                                                             tree_find_le);
                                 break;
        case NEXT_RECORD:        feedback = read_scan_record (record,
                                                              key,
                                                              tree_next);
                                 break;
        case PRIOR_RECORD:       feedback = read_scan_record (record,
                                                              key,
                                                              tree_prev);
                                 break;
        case LAST_RECORD:        feedback = read_scan_record (record,
                                                              key,
                                                              tree_last);
                                 break;
        default:                 feedback = ILLEGAL_MODE;
      }

    if (feedback == OK)
	memcpy (record, &cur_record_item-> record, sizeof ($(TN)));

.if $(TRACE?0)
    coprintf ("$(tn)_get : feedback = %d", feedback);

.endif
    return feedback;
}


int read_key_record ($(TN) *record, int key, TREE_FIND *tree_find)
{
    TREE
        *t;
    int
        feedback;

    switch (key)
      {
.for KEY
        case $(KEY.NAME):
            t = (*tree_find) (&$(KEY.name)_tree,
                              (char *) record - $(count (TABLE.KEY) - index () + 1) * sizeof (TREE),
                              $(KEY.name)_cmp);
            if (t)
	      {
		cur_record_item = (RECORD_ITEM *)
                                  ((char *) t - $(index () - 1) * sizeof (TREE));
	        feedback = OK;
              }
            else
                feedback = RECORD_NOT_PRESENT;
            break;
.endfor
        default:
            feedback = ILLEGAL_MODE;
            break;
      }
    return (feedback);
}


int read_scan_record ($(TN) *record, int key, TREE_SCAN *tree_scan)
{
    TREE
        *t;
    int
        feedback;

    switch (key)
      {
.for KEY
        case $(KEY.NAME):
            t = (*tree_scan) (&cur_record_item-> $(KEY.name)_item);
            if (t)
	      {
		cur_record_item = (RECORD_ITEM *)
                                  ((char *) t - $(index () - 1) * sizeof (TREE));
	        feedback = OK;
              }
            else
                feedback = RECORD_NOT_PRESENT;
            break;
.endfor
        default:
            feedback = ILLEGAL_MODE;
            break;
      }
    return (feedback);
}


/*  ---------------------------------------------------------------------[<]-
    Function: $(tn)_update

    Synopsis: update a record into the table $(TN).
    ---------------------------------------------------------------------[>]-*/
int
$(tn)_update ($(TN) *record)
{
    RECORD_ITEM
        *record_item = NULL;
    int
.for KEY
        $(KEY.name)_feedback = DUPLICATE_RECORD,
.endfor
        feedback = OK;

.for KEY where index () = 1
    if ($(KEY.name)_tree == NULL)
        return ILLEGAL_FILE_USAGE;
.endfor

    if (cur_record_item == NULL)
        return RECORD_NOT_PRESENT;

.for KEY by DUPLICATES
    if ((feedback == OK)
    &&  ($(KEY.name)_cmp ((char *) record - $(count (TABLE.KEY) - index () + 1) * sizeof (TREE),
                          &cur_record_item-> $(KEY.name)_item) != 0))
      {
        if (record_item == NULL)
          {
            record_item = memt_alloc (the_transaction, sizeof (RECORD_ITEM));
            ASSERT (record_item);
            memcpy (&record_item-> record, record, sizeof ($(TN)));
          }

        $(KEY.name)_feedback = tree_insert (&$(KEY.name)_tree,
	                                    &record_item-> $(KEY.name)_item,
	                                    $(KEY.name)_cmp,
                                            $(DUPLICATES));
        feedback = $(KEY.name)_feedback;
      }        
.endfor

    if (feedback == OK)
        if (record_item == NULL)        /*  No keys changed                  */
          {
            memcpy (&cur_record_item-> record, record, sizeof ($(TN)));
            return OK;
          }
        else
          {
.for KEY by DUPLICATES
            tree_delete (&$(KEY.name)_tree,
                         &cur_record_item-> $(KEY.name)_item);

            if ($(KEY.name)_cmp ((char *) record - $(count (TABLE.KEY) - index () + 1) * sizeof (TREE),
                                 &cur_record_item-> $(KEY.name)_item) == 0)
              {
                $(KEY.name)_feedback = tree_insert (&$(KEY.name)_tree,
	                                            &record_item-> $(KEY.name)_item,
		                                    $(KEY.name)_cmp,
                                                    $(DUPLICATES));
                if ($(KEY.name)_feedback != OK)
                    return RECORD_INTEGRITY;
              }

.endfor
            cur_record_item = record_item;
            return OK;
          }

.for KEY where DUPLICATES = "FALSE"
    if ($(KEY.name)_feedback == OK)
        tree_delete (&$(KEY.name)_tree, &record_item-> $(KEY.name)_item);
.endfor

    mem_free (record_item);
    return DUPLICATE_RECORD;
}


/*  ---------------------------------------------------------------------[<]-
    Function: $(tn)_delete

    Synopsis: delete a record from the table $(TN)
    ---------------------------------------------------------------------[>]-*/
int
$(tn)_delete ($(TN) *record, int key)
{
    int
        feedback = OK;

.for KEY where index () = 1
    if ($(KEY.name)_tree == NULL)
        return ILLEGAL_FILE_USAGE;
.endfor

    feedback = $(tn)_get (record, EQUAL_TO, key, 0);
    if (feedback == OK)
      {
.for KEY
        tree_delete (&$(KEY.name)_tree,
                     &cur_record_item-> $(KEY.name)_item);
.endfor
        mem_free (cur_record_item);
        cur_record_item = NULL;
      }
    return feedback;
}


/*  ---------------------------------------------------------------------[<]-
    Function: $(tn)_commit

    Synopsis: commit changes to the table $(TABLE.NAME)
    ---------------------------------------------------------------------[>]-*/
int
$(tn)_commit (void)
{
    int
       feedback;

.for KEY where index () = 1
    if ($(KEY.name)_tree == NULL)
        return ILLEGAL_FILE_USAGE;

    xml_root = xml_new (NULL, NULL, NULL);
    tree_traverse ($(KEY.name)_tree,
                   load_record_into_xml,
                   0);
    feedback = xml_save (xml_root, "$(tn).xml");
    xml_free (xml_root);
    if (feedback < 0)
        return HARD_ERROR;
    else
        return OK;
.endfor
}


void load_record_into_xml (void *t)
{
    RECORD_ITEM
        *record_item;
    XML_ITEM
        *xml_item;

    record_item = (RECORD_ITEM *) t;

    xml_item = xml_new (xml_root, "$(TABLE.NAME)", NULL);
.for FIELD
.    if TYPE = "NUMERIC" | TYPE = "DATE" | TYPE = "TIME"
    if (record_item-> record. $(name:c) > 0)
      {
        sprintf (buffer, "%ld", (long) record_item-> record. $(name:c));
        xml_put_attr (xml_item, "$(name:c)", buffer);
      }
.    elsif TYPE = "BOOLEAN"
    if (record_item-> record. $(name:c))
        xml_put_attr (xml_item, "$(name:c)", "TRUE");
    else
        xml_put_attr (xml_item, "$(name:c)", "FALSE");
.    elsif SIZE <= 1
    if (record_item-> record. $(name:c) > 0)
      {
        sprintf (buffer, "%c", record_item-> record. $(name:c));
        xml_put_attr (xml_item, "$(name:c)", buffer);
      }
.    else
    if (record_item-> record. $(name:c) [0] > 0)
        xml_put_attr (xml_item, "$(name:c)", record_item-> record. $(name:c));
.    endif
.endfor
}


/*  ---------------------------------------------------------------------[<]-
    Function: $(tn)_close

    Synopsis: close the table $(TABLE.NAME)
    ---------------------------------------------------------------------[>]-*/
int
$(tn)_close (void)
{
    int
       feedback;

    feedback = $(tn)_commit ();
    mem_rollback (the_transaction);

.for KEY
    $(KEY.name)_tree  = NULL;
.endfor

    return feedback;
}


/*  ---------------------------------------------------------------------[<]-
    Function: $(tn)_clear

    Synopsis: set char field zone not used with 0
    ---------------------------------------------------------------------[>]-*/
void
$(tn)_clear ($(TABLE.NAME) *record)
{
    int
        length = 0;

.for FIELD
.   if TYPE = "TEXTUAL" & SIZE > 1
    length = strlen (record-> $(name:c));
    memset (&record-> $(name:c) [length], 0, $(SIZE + 1) - length);
.   endif
.endfor
}
